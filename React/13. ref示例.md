## ref分析
> 为什么有`ref`,虽然官方总是不推荐使用这种破坏整体框架的api,但是实际开发,总有一些场景需要直接操作DOM元素,所以有了这个api.但是如果能不使用尽量不使用.
- 破坏了"属性和状态去映射视图",正常流程中的组件属性均有数据映射而来,绑定了ref相当于提供直接修改属性的额外途径,导致属性不可控.
- 破坏了"属性不可变性，单向数据流",增加额外了操作数据的途径,可能改变属性不可变性,让数据的流动不可控.
- 降低了可读性,破坏了整体代码风格和组织结构.

虽然,有种种不利,但是在一些场景确实有效并且真香~

## ref使用场景
1. 获取DOM的css属性.
    - 绘图
    1. 通过canvas元素获取画板上下文
    2. 通过canvas元素获取父元素宽度和高度，自适应自身高度和宽度
    3. 监听父元素resize，更新视图。
    ```
    <div id="root-canvas" ></div>
    ```
    ```
    class DrawPanel extends React.Component {
        constructor(props) {
            super(props)
            this.state = {
                value: 1
            }
        }
        handleChange = (e) => {
            this.setState({
                value: e.target.value
            })
        }
        render () {
            return (
                <div style={{ width: "100%", height: "400px" }}>
                    <DrawRing value={this.state.value} />
                    {this.state.value}
                    <input type="range" value={this.state.value} onChange={
                        this.handleChange
                    } />
                </div>
            )
        }
    }


    class DrawRing extends React.Component {
        canvas = React.createRef()
        constructor(props) {
            super(props);
        }
        componentDidMount () {
            this.currentValue = 0;
            this.ctx = this.canvas.current.getContext('2d');
            this.clear();
            this.draw();
            this.canvas.current.parentNode.addEventListener('resize', () => {
                this.clear();
                this.draw();
            })
        }

        componentDidUpdate () {
            this.clear();
            this.draw();
        }

        clear () {
            const canvas = this.canvas.current;
            const parentNode = canvas.parentNode;
            canvas.width = parentNode.offsetWidth;
            canvas.height = parentNode.offsetHeight;
            this.centerPos = [canvas.width / 2, canvas.height / 2];
        }
        draw () {
            let { value = 10, color = 'red', duration = 1000, bgColor = '#e3e3e3', wd = 0 } = this.props,
                ctx = this.ctx,
                centerPos = this.centerPos,
                r = 1.5 * Math.min.apply(null, centerPos) / 2,
                currentValue = this.currentValue, speed = 3.6 * 10 * (value - currentValue) / duration;
            speed = Math[speed >0 ?  'max': 'min'](speed > 0 ? 0.0001 : -0.0001, speed);
            wd = wd || r / 5;
            currentValue += speed;
            if (speed > 0 && currentValue + speed > value) {
                currentValue = value
            }
            if (speed < 0 && currentValue + speed < value) {
                currentValue = value
            }
            ctx.beginPath();
            ctx.arc(centerPos[0], centerPos[1], r, 0, Math.PI * 2 * (currentValue / 100), false);
            ctx.strokeStyle = color;
            ctx.lineWidth = wd;
            ctx.stroke()
            ctx.closePath();
            ctx.beginPath();
            ctx.arc(centerPos[0], centerPos[1], r, Math.PI * 2 * (currentValue / 100), Math.PI * 2, false);
            ctx.strokeStyle = bgColor;
            ctx.lineWidth = wd;
            ctx.stroke()
            ctx.closePath();
            ctx.beginPath();
            ctx.font = "normal normal normal " + r / 4 + "px arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = color;
            ctx.fillText((Math.ceil(currentValue*100)/100).toFixed(2)  + "%", centerPos[0], centerPos[1])
            ctx.closePath();

            this.currentValue = Number(currentValue);
            clearTimeout(this.timer);
            if (currentValue != value) {
                this.timer = setTimeout(() => {
                    this.clear();
                    this.draw();
                })
            }
        }
        render () {
            return <div style={{ height: "100%", width: "100%" }}><canvas height={0} width={0} ref={this.canvas}>Your browser does not support the canvas element.</canvas></div>
        }
    }

    ReactDOM.render(<DrawPanel />, document.querySelector('#root-canvas'))
    ```
    ps：写这个demo过程遇到一个问题，父组件中state变化，触发子组件的props变化，到底应该在什么周期中进行操作（留到后面生命周期章节再详细分析）。
    - 购物车动画
    ```
    ```

2. 绑定事件
    - 表单操作
    ```
    ```

3. 越级操作组件
    - 调用方法(超级不推荐)
    ```
    ```
    - 修改数据(超级不推荐)
    ```
    ```




