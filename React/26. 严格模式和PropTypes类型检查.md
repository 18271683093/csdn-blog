## 严格模式
> `StrictMode`是一个用来图突出显示应用程序中潜在问题的工具。和`Fragment`一样，`StrictMode`不会渲染任何可见的UI。他为其后台元素触发额外的检查和警告。严格模式检查仅在开发模式下运行；它们不会影响生产构建。

启用严格模式，例如：
```
import React from 'react';
function ExampleApplication() {
  return (
    <div>
      <Header />
      <React.StrictMode>
        <div>
          <ComponentOne />
          <ComponentTwo />
        </div>
      </React.StrictMode>
      <Footer />
    </div>
  );
}
```
在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。
`StrictMode`针对React进行检查：
- 识别不安全的生命周期
- 关于使用过时的字符串refAPI的警告
- 关于使用废弃的findDOMNode方法的警告
- 检查意外的副作用
- 检查过时的contentAPI

## 识别不安全的生命周期
这里的“不安全”不是指真正意义上的不安全，而是指经常被误解和滥用，并且在异步渲染中，潜在误用的可能性更大，所以在后续React版本中会被加上`UNSAFE_`前缀的API。而使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。所以称之为不安全的生命周期：
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate

## 过时的refAPI
以前，React提供了两种管理refs的方式：
1. 字符串Ref API
2. 回调函数API
3. `React.createRef`
比较：
- string ref 不可组合（React.createRef也不行）:即子组件内部使用过了ref属性绑定过了一个由父组件传进来的组件，父组件里对这个组件的绑定的ref就失效了。
```
class Parent extends React.Component {
    componentDidMount () {
        console.log(this.refs)
    }
    render () {
        const { children } = this.props;
        return <div>
            {children.map((child,index)=>React.cloneElement(child,{
                ref:"childref"+index,
                key:index
            }))}
        </div>

    }
}

class App extends React.Component {
    componentDidMount () {
        console.log(this.Divref)
        console.log(this.refs)
    }
    render () {
        this.Divref = React.createRef();
        return <Parent >
            <div ref="appdiv">app</div>
            <div ref={this.Divref}>app</div>
        </Parent>
    }
}
```
如上，App组件中打印的都是空，而在Parent中能打印出来。

- string ref的所有者，由当前执行的组件决定，而不是设置的组件。例如在`render props`中。
```
class Parent extends React.Component {
    componentDidMount () {
        console.log(this.refs)
        console.log(this.Divref)
    }
    render () {
        const { render } = this.props;

        return <div>
            {render()}
        </div>

    }
}

class App extends React.Component {
    constructor(props){
        super(props)
        this.renderProp = this.renderProp.bind(this)
    }
    componentDidMount () {
        console.log('-------------- app componentDidMount --------------')
        console.log(this.Divref)
        console.log(this.refs)
    }
    renderProp () {
        this.Divref = React.createRef();
        return <React.Fragment>
            <div ref="appdiv">app1</div>
            <div ref={this.Divref}>app2</div>
        </React.Fragment>
    }
    render () {
        return <Parent render={this.renderProp} >
        </Parent>
    }
}
```
输出：
```
{appdiv: div}
undefined
-------------- app componentDidMount --------------
{current: div}
{}
```
3. string ref 不适用于Flow之类的静态分析。Flow不能猜测框架可以使字符串ref“出现”在react上的神奇效果，以及它的类型（可能有所不同）。回调引用比静态分析更友好。
4. string ref 强制React跟踪当前正在执行的组件。这是有问题的，因为它使react模块处于有状态，并在捆绑中复制react模块时导致奇怪的错误。在 reconciliation 阶段，React Element 创建和更新的过程中，ref 会被封装为一个闭包函数，等待 commit 阶段被执行，这会对 React 的性能产生一些影响。
5. 以上问题使用回调函数形式会更好。

这也是为什么字符串ref称为过时的原因。

## 关于使用废弃的 findDOMNode 方法的警告
React 支持用 findDOMNode 来在给定 class 实例的情况下在树中搜索 DOM 节点。通常你不需要这样做，因为你可以将 ref 直接绑定到 DOM 节点。

findDOMNode 也可用于 class 组件，但它违反了抽象原则，它使得父组件需要单独渲染子组件。它会产生重构危险，你不能更改组件的实现细节，因为父组件可能正在访问它的 DOM 节点。findDOMNode 只返回第一个子节点，但是使用 Fragments，组件可以渲染多个 DOM 节点。findDOMNode 是一个只读一次的 API。调用该方法只会返回第一次查询的结果。如果子组件渲染了不同的节点，则无法跟踪此更改。因此，findDOMNode 仅在组件返回单个且不可变的 DOM 节点时才有效。

你可以通过将 ref 传递给自定义组件并使用 ref 转发来将其传递给 DOM 节点。

你也可以在组件中创建一个 DOM 节点的 wrapper，并将 ref 直接绑定到它。






